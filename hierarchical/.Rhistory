rawCounts
thetaZ <- c (sum(rawCounts[,,1]),sum(rawCounts[,,2])
)
thetaZ
thetaZ <- c (sum(rawCounts[,,1]),sum(rawCounts[,,2])) / sum (rawCounts)
thetaZ
thetaXY[,,1] <- rawCounts[,,1]/sum(rawCounts[,,1])
thetaXY[,,2] <- rawCounts[,,2]/sum(rawCounts[,,2])
condMutualInfo(thetaZ,thetaXY)
i <- 1
for (z in 1:zLevels){
thetaZhat[z] <- sum(rawCounts[,,z]) / sum(rawCounts)
mutualZemp[z] <- mi.empirical(rawCounts[,,z])
mutualZJames[z] <- mi.shrink(rawCounts[,,z])
}
miEmpHausser[i] <- sum(thetaZhat * mutualZemp)
miJamesHausser[i] <- sum(thetaZhat * mutualZJames)
miEmpHausser
miEmpHausser[1]
miJamesHausser[1]
arity <-2
alphaVector <- array(1,c(1,arity))
marginal <- rdirichlet(1,alphaVector)
conditionalX <- t(rdirichlet(arity,alphaVector))
conditionalY <- t(rdirichlet(arity,alphaVector))
alphaVector
marginal
conditionalX
conditionalY
source('~/Documents/devel/workspace/independenceTest/independenceTest/condMutualInfo.R')
library('MCMCpack')
#assumes all variables to have the same arity
#generates the CPTs
alphaVector <- array(1,c(1,arity))
marginal <- rdirichlet(1,alphaVector)
conditionalX <- t(rdirichlet(arity,alphaVector))
conditionalY <- t(rdirichlet(arity,alphaVector))
samples <- 50
Z <- sample (seq(1:arity), size = samples, replace = TRUE, prob = marginal)
#just init. Actual values are filled later
X <- Z
Y <- Z
#sample the feature1
for (currentState in 1:arity){
X[Z==currentState] <-
sample (seq(1:arity), size = sum(Z==currentState), replace = TRUE, prob = conditionalX[,currentState])
Y[Z==currentState] <-
sample (seq(1:arity), size = sum(Z==currentState), replace = TRUE, prob = conditionalY[,currentState])
}
stateSequence <- 1:arity
XF <- factor (X,levels=stateSequence)
ZF <- factor (Z,levels=stateSequence)
YF <- factor (Y,levels=stateSequence)
joint <- array(0,dim=c(levelsX,levelsY,levelsZ))
for (x in 1:levelsX){
for (y in 1:levelsY){
for (z in 1:levelsZ){
joint[x,y,z] <- marginal[z] * conditionalX[x,z] * conditionalY[y,z]
}
}
}
joint
marginal
sum(joint)
marginal
apply(joint,sum,3)
apply(joint,3,sum)
apply(joint,c(1,2),sum)
sum(apply(joint,c(1,2),sum))
miXYGivenZ <- condMutualInfo(marginal,apply(joint,c(1,2),sum))
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
miXYGivenZ <- condMutualInfo(marginal,apply(joint,c(1,2),sum))
miXYGivenZ <- condMutualInfo(marginal,apply(joint,c(1,2),sum))
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
miXYGivenZ <- condMutualInfo(marginal,apply(joint,c(1,2),sum))
debugSource('~/Documents/devel/workspace/independenceTest/independenceTest/condMutualInfo.R')
debugSource('~/Documents/devel/workspace/independenceTest/independenceTest/condMutualInfo.R')
miXYGivenZ <- condMutualInfo(marginal,apply(joint,c(1,2),sum))
thetaXY
thetaXY[,,1]
zState
levelsX
levelsY
levelsZ
matrix (thetaXY[,,zState], nrow = levelsX, ncol = levelsY)
jointGivenZ <- matrix (thetaXY[,,zState], nrow = levelsX, ncol = levelsY)
marginalX <- apply (jointGivenZ, 1, sum)
marginalY <- apply (jointGivenZ, 2, sum)
miXYGivenZ <- condMutualInfo(marginal,apply(joint,c(1,2),sum))
levelsX
levelsY
levelsZ
matrix(thetaXY[, , zState], nrow = levelsX, ncol = levelsY)
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
marginalY <- apply(joint,2,sum)
thetaXZ <- apply(joint,c(1,3),sum)
marginalY
thetaXY
joint
marginalY
thetaXZ <- apply(joint,c(1,3),sum)
thetaXZ
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
thetaXYgivenZ <-joint #initialization
for (z in 1:zLevels){
thetaXYgivenZ[,,z] <- joint[,,z]/sum(joint[,,z])
}
thetaXYgivenZ <-joint #initialization
for (z in 1:zLevels){
thetaXYgivenZ[,,z] <- joint[,,z]/sum(joint[,,z])
}
thetaXYgivenZ
miXYGivenZ <- condMutualInfo(marginal, thetaXYgivenZ)
miXYGivenZ
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
marginalY <- apply(joint,2,sum)
thetaXZgivenY <-joint #initialization
for (y in 1:yLevels){
thetaXZgivenY[,y,] <- joint[,y,]/sum(joint[,y,])
}
miXZGivenY <- condMutualInfo(marginalY,thetaXZ)
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
marginalY <- apply(joint,2,sum)
thetaXZgivenY <-joint #initialization
for (y in 1:levelsY) {
thetaXZgivenY[,y,] <- joint[,y,]/sum(joint[,y,])
}
miXZGivenY <- condMutualInfo(marginalY,thetaXZ)
debugSource('~/Documents/devel/workspace/independenceTest/independenceTest/condMutualInfo.R')
marginalY <- apply(joint,2,sum)
thetaXZgivenY <-joint #initialization
for (y in 1:levelsY) {
thetaXZgivenY[,y,] <- joint[,y,]/sum(joint[,y,])
}
marginalY <- apply(joint,2,sum)
thetaXZgivenY <-joint #initialization
for (y in 1:levelsY) {
thetaXZgivenY[,y,] <- joint[,y,]/sum(joint[,y,])
}
miXZGivenY <- condMutualInfo(marginalY,thetaXZ)
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
miXZGivenY <- condMutualInfo(marginalY,thetaXZgivenY)
miXZGivenY <- condMutualInfo(marginalY,thetaXZgivenY)
myList <- list("genData" = data.frame(XF,YF, ZF), "miXYGivenZ"=miXYGivenZ, "miXZGivenY"=miXZGivenY)
myList <- list("genData" = data.frame(XF,YF, ZF), "miXYGivenZ"=miXYGivenZ, "miXZGivenY"=miXZGivenY)
source('~/Documents/devel/workspace/independenceTest/independenceTest/genIndepNaiveData.R')
myList
source('~/Documents/devel/workspace/independenceTest/independenceTest/condMutualInfo.R')
source('~/Documents/devel/workspace/independenceTest/independenceTest/genNaiveData.R')
debugSource('~/Documents/devel/workspace/independenceTest/independenceTest/debugMI.R')
debugSource('~/Documents/devel/workspace/independenceTest/independenceTest/debugMI.R')
reps <- 100
miMeyer <- vector(length = reps)
miMeyerShr <- vector(length = reps)
miEmpHausser <- vector(length = reps)
miJamesHausser <- vector(length = reps)
miCorani <- vector(length = reps)
for (i in 1:reps){
tmpData <- genIndepNaiveData(samples=10)
zLevels <- max(levels(tmpData$ZF))
miMeyer[i] <- condinformation( tmpData$XF, tmpData$YF, tmpData$ZF, method="emp")
miMeyerShr[i] <- condinformation( tmpData$XF, tmpData$YF, tmpData$ZF, method="shrink")
rawCounts <- jointBayesianCounts (tmpData, ess=0)
thetaZhat <- array(dim=zLevels)
mutualZemp <- array(dim=zLevels)
mutualZJames <- array(dim=zLevels)
for (z in 1:zLevels){
thetaZhat[z] <- sum(rawCounts[,,z]) / sum(rawCounts)
mutualZemp[z] <- mi.empirical(rawCounts[,,z])
mutualZJames[z] <- mi.shrink(rawCounts[,,z])
}
miEmpHausser[i] <- sum(thetaZhat * mutualZemp)
miJamesHausser[i] <- sum(thetaZhat * mutualZJames)
smoothedCounts <- jointBayesianCounts (tmpData)
miCorani[i] <- mean (posteriorMI(smoothedCounts))
}
i <- 1
tmpData <- genIndepNaiveData(samples=10)
zLevels <- max(levels(tmpData$ZF))
miMeyer[i] <- condinformation( tmpData$XF, tmpData$YF, tmpData$ZF, method="emp")
miMeyerShr[i] <- condinformation( tmpData$XF, tmpData$YF, tmpData$ZF, method="shrink")
mean(c(30,60,35,25))
37.5/1.128
library("bnlearn", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
?ci.test
load("~/Dropbox/research/CredalMulti (1)/gc/jointMarginal.Rdata")
rm(lis=ls())
rm(list=ls())
load("~/Dropbox/research/CredalMulti (1)/gc/jointMarginal.Rdata")
wilcox.test(marginal$MNCC.u80,marginal$MNBC.acc)
wilcox.test(marginal$MNCC.u80,marginal$MNBC.acc)
binom.test(marginal$MNCC.u80,marginal$MNBC.acc)
sum(marginal$MNCC.u80>marginal$MNBC.acc)
length(marginal$MNCC.u80)
binom.test(13,15)
sum(marginal$MNCC.u80>marginal$MNBC.acc,paired=TRUE)
wilcox.test(marginal$MNCC.u80,marginal$MNBC.acc,paired=TURE)
wilcox.test(marginal$MNCC.u80,marginal$MNBC.acc,paired=TRUE)
wilcox.test(marginal$MNCC.u80,marginal$NCC.u80,paired=TRUE)
marginal$MNCC.u80
sum(marginal$MNCC.u80>marginal$NCC.u80)
sum(marginal$MNCC.u80<marginal$NCC.u80)
sum(joint$MNCC.u80<joint$NCC.u80)
sum(joint$MNCC.u80>joint$NCC.u80)
sum(joint$MNCC.u80==joint$NCC.u80)
wilcox.test(joint$MNCC.u80,joint$NCC.u80,paired=TRUE)
wilcox.test(joint$MNCC.u80,joint$MNBC.acc,paired=TRUE)
wilcox.test(joint$MNCC.u80,joint$NBC.acc,paired=TRUE)
wilcox.test(joint$MNCC.u65,joint$MNBC.acc,paired=TRUE)
wilcox.test(joint$MNCC.u65,joint$MNBC.acc,paired=TRUE)
wilcox.test(marginal$MNCC.u65,marginal$MNBC.acc,paired=TRUE)
wilcox.test(marginal$MNCC.u65,marginal$NBC.acc,paired=TRUE)
wilcox.test(marginal$MNCC.u80,marginal$NBC.acc,paired=TRUE)
wilcox.test(marginal$MNCC.u80,marginal$MNBC.acc,paired=TRUE)
wilcox.test(marginal$MNCC.u65,marginal$MNBC.acc,paired=TRUE)
wilcox.test(marginal$MNCC.u65,marginal$NCC.u65,paired=TRUE)
wilcox.test(marginal$MNCC.u80,marginal$NCC.u80,paired=TRUE)
t.test(marginal$MNCC.u80,marginal$NCC.u80,paired=TRUE)
load("~/Dropbox/research/CredalMulti (1)/gc/jointMarginal.Rdata")
wilcox.test(joint$MNCC.u65,joint$MNBC.acc,paired=TRUE)
joint
wilcox.test(joint$MNCC.u80,joint$MNBC.acc,paired=TRUE)
wilcox.test(joint$MNCC.u80,joint$MNBC.acc,paired=TRUE)
wilcox.test(joint$MNCC.u80,joint$NCC.u65,paired=TRUE)
wilcox.test(joint$MNCC.u80,joint$NCC.u80,paired=TRUE)
wilcox.test(joint$MNCC.u80,joint$NBC.acc,paired=TRUE)
wilcox.test(joint$MNCC.u80,joint$NBC.acc,paired=TRUE)
wilcox.test(joint$MNCC.u80,joint$NCC.u80,paired=TRUE)
wilcox.test(joint$MNCC.u80,joint$NBC.acc,paired=TRUE)
wilcox.test(joint$MNCC.u80,joint$MNCC.u80,paired=TRUE)
wilcox.test(joint$MNCC.u80,joint$MNBC.u80,paired=TRUE)
wilcox.test(marginal$MNCC.u80,marginal$MNBC.u65,paired=TRUE)
wilcox.test(marginal$MNCC.u65,marginal$NCC.u65,paired=TRUE)
wilcox.test(marginal$MNCC.u65,marginal$NBC.acc,paired=TRUE)
wilcox.test(marginal$MNCC.u80,marginal$NBC.acc,paired=TRUE)
wilcox.test(marginal$MNCC.u80,marginal$NCC.u80,paired=TRUE)
wilcox.test(marginal$MNCC.u65,marginal$NCC.u65,paired=TRUE)
t.test(marginal$MNCC.u65,marginal$NCC.u65,paired=TRUE)
t.test(marginal$MNCC.u65,marginal$MNBC.acc,paired=TRUE)
t.test(marginal$MNCC.u80,marginal$MNBC.acc,paired=TRUE)
t.test(marginal$NCC.u80,marginal$MNCC.u80,paired=TRUE)
t.test(marginal$NCC.u65,marginal$MNCC.u65,paired=TRUE)
library("bnlearn", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
?iamb
iamb
ia.markov.blanket
ia.markov.blanket()
indep.test
indep.test()
?entropy
t <- c (93,85,95,91,92,90)
t
t.test()
?t.test
t.test(t,mu = 90)
ttest <- t.test(t,mu = 90)
ttest
ttest$estimate
ttest$parameter
sd(t)
1/(3.4/sqrt(6))
6*0.177/12
qcc
library("qcc", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
pbinom
?pbinom
dbinom(0,10,0.006)
dbinom(1,10,0.006)
dbinom(2,10,0.006)
sqrt(.01*.99/1000)
.06*(1-0.6)/1000
sqrt(.06*(1-0.6)/100)
?rep
rep(1,5)
?sample
condStates <- 3
onesVector <- rep(1,condStates)
onesVector
marginalZ <- rdirichlet(1,onesVector)
library('MCMCpack')
marginalZ <- rdirichlet(1,onesVector)
marginalZ
sample([1,2,3],50,replace=TRUE,prob=[.4,.5,.1])
sample([1,2,3],50,replace=TRUE,prob=c(.4,.5,.10)
sample([1,2,3],50,replace=TRUE,prob=c(.4,.5,.10)]
sample([1,2,3],50,replace=TRUE,prob=c(.4,.5,.10))
sample(c(1,2,3),50,replace=TRUE,prob=c(.4,.5,.10) )
tmp<-sample(c(1,2,3),100000,replace=TRUE,prob=c(.4,.5,.10) )
mean(tmp==1)
mean(tmp==2)
mean(tmp==3)
library('MCMCpack')
library(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
zStates <- 1:condStates
XYstates <- 1:4
alpha <- 1:length(XYstates)
theta <- matrix(nrow = condStates, ncol = XYstates)
for (i in 1:condStates){
theta[i,] <- rdirichlet(1,alpha)
}
zStates
XYstates
alpha
theta
theta <- matrix(nrow = condStates, ncol = XYstates)
theta
theta <- matrix(nrow = condStates, ncol = length(XYstates))
theta
i <- 1
theta[i,] <- rdirichlet(1,alpha)
for (i in 1:condStates){
theta[i,] <- rdirichlet(1,alpha)
}
theta
apply(theta,2,sum)
apply(theta,1,sum)
onesVector <- rep(1,condStates)
marginalZ <- rdirichlet(1,onesVector)
marginalZ
ZCounts <- sample (1:zStates,trainingSamples,replace = TRUE, prob = marginalZ)
ZCounts <- sample (zStates,trainingSamples,replace = TRUE, prob = marginalZ)
trainingSamples
trainingSamples <- 50
ZCounts <- sample (zStates,trainingSamples,replace = TRUE, prob = marginalZ)
ZCounts
table(ZCounts)
class(table(ZCounts))
?table
tab <- table(ZCounts)
source('~/Dropbox/research/working-papers/transfer/dirHierTest.R')
Zvalues <- sample (zStates,trainingSamples,replace = TRUE, prob = marginalZ)
Zvalues
Zcounts <- table (Zvalues)
Zcounts
Zcounts[1]
Zcounts[2]
Zcounts[3]
Zcounts[2,1]
Zcounts[1,12]
Zcounts[1,2]
as.numeric(table(Zvalues))
Zvalues <- sample (zStates,trainingSamples,replace = TRUE, prob = marginalZ)
Zcounts <- as.numeric(table(Zvalues))
Zcounts
XYcounts <- matrix (nrow = condStates, ncol = XYstates)
XYcounts
XYcounts <- matrix (nrow = length(zStates), ncol = length(XYstates))
i <- 1
XYvalues <-  sample (1:XYstates,ZCounts[i],replace = TRUE, prob = theta[i,])
sample (1:XYstates,ZCounts[i],replace = TRUE, prob = theta[i,])
1:XYstates
1:length(XYstates)
XYvalues <-  sample (1:length(XYstates),ZCounts[i],replace = TRUE, prob = theta[i,])
XYvalues
ZCounts[i]
i
ZCounts
Zvalues <- sample (zStates,trainingSamples,replace = TRUE, prob = marginalZ)
Zcounts <- as.numeric(table(Zvalues))
ZCounts
Zvalues <- sample (zStates,trainingSamples,replace = TRUE, prob = marginalZ)
Zcounts <- as.numeric(table(Zvalues))
Zcounts
XYvalues <-  sample (1:length(XYstates),Zcounts[i],replace = TRUE, prob = theta[i,])
i
XYvalues
length(XYvalues)
XYvalues <-  sample (1:length(XYstates),Zcounts[i],replace = TRUE, prob = theta[i,])
XYvalues
XYcounts <- as.numeric(table(XYvalues))
XYcounts
table(XYvalues)
?table
Zcounts <- table(factor(x, levels = 0:14))
Zcounts <- table(factor(Zvalues, levels = condStates))
Zvalues
as.numeric(table(Zvalues))
table(factor(Zvalues, levels = condStates))
Zcounts <- table(factor(Zvalues, levels = Zvalues))
Zcounts
Zvalues
Zcounts <- table(factor(Zvalues, levels = zStates))
Zcounts
zStates <- 1:condStates
xyStates <- 1:4
alpha <- 1:length(XYstates)
onesVector <- rep(1,condStates)
marginalZ <- rdirichlet(1,onesVector)
Zvalues <- sample (zStates,trainingSamples,replace = TRUE, prob = marginalZ)
library('MCMCpack')
library(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
zStates <- 1:condStates
xyStates <- 1:4
alpha <- 1:length(xyStates)
theta <- matrix(nrow = condStates, ncol = length(xyStates))
for (i in 1:condStates){
theta[i,] <- rdirichlet(1,alpha)
}
onesVector <- rep(1,condStates)
marginalZ <- rdirichlet(1,onesVector)
marginalZ
Zvalues <- sample (zStates,trainingSamples,replace = TRUE, prob = marginalZ)
Zcounts <- as.numeric(table(factor(Zvalues, levels = zStates)))
Zcounts
XYcounts <- matrix (nrow = length(zStates), ncol = length(xyStates))
XYvalues <-  sample (1:length(xyStates),Zcounts[i],replace = TRUE, prob = theta[i,])
i <- 1
xyValues <-  sample (1:length(xyStates),Zcounts[i],replace = TRUE, prob = theta[i,])
xyCounts <- as.numeric(table(XYvalues))
xyCounts
xyValues <-  sample (1:length(xyStates),Zcounts[i],replace = TRUE, prob = theta[i,])
xyCounts <- as.numeric(table(factor(xyValues, levels = xyStates)))
xyCounts
xyValues
xyCounts
xyCounts[1]<-0
xyCounts <- as.numeric(table(factor(xyValues, levels = xyStates)))
xyCounts
xyValues
xyValues[2]<-2
xyCounts <- as.numeric(table(factor(xyValues, levels = xyStates)))
xyCounts
XYcounts <- matrix (nrow = length(zStates), ncol = length(xyStates))
for (i in 1:condStates){
xyValues <-  sample (1:length(xyStates),Zcounts[i],replace = TRUE, prob = theta[i,])
xyCounts[i,] <- as.numeric(table(factor(xyValues, levels = xyStates)))
}
i <- 1
xyValues <-  sample (1:length(xyStates),Zcounts[i],replace = TRUE, prob = theta[i,])
xyCounts[i,] <- as.numeric(table(factor(xyValues, levels = xyStates)))
xyCounts <- matrix (nrow = length(zStates), ncol = length(xyStates))
for (i in 1:condStates){
xyValues <-  sample (1:length(xyStates),Zcounts[i],replace = TRUE, prob = theta[i,])
xyCounts[i,] <- as.numeric(table(factor(xyValues, levels = xyStates)))
}
xyCounts
ZCounts
Zcounts
rm(ZCounts)
xyValues
Zcounts
xyCounts
alpha <- 1:length(xyStates)
alpha
disp(alpha)
print(alpha)
print(paste("actual alpha:",alpha))
print("actual alpha:")
print(alpha)
print('\n')
?writeLines
writeLines(c('actual',alpha))
writeLines(c('actual alpha',alpha))
writeLines()
writeLines(c(""))
print('actual alpha:')
print(alpha)
writeLines(c(""))
library(mlbench)
library(caret)
data(PimaIndiansDiabetes)
control <- trainControl(method="repeatedcv", number=10, repeats=3)
currentSeed<-7
data <- mlbench.friedman1(10000, sd=10)
summary(data$y)
cut.vec <- cut(data$y, breaks=quantile(data$y, 0:3/3), include.lowest=T, right=FALSE)
data$class <- cut.vec
data$class
as.numeric(data$class)
set.seed(currentSeed)
fit.cart <- train(data$x, data$class, method="rpart1SE", trControl=control,tuneGrid=NULL, tuneLength = 1)
fit.cart
fit.cart$resample$Accuracy
length(fit.cart$resample$Accuracy)
set.seed(currentSeed)
fit.lda <- train(data$x, data$class, method="lda", trControl=control, tuneLength = 1)
ldaAccuracy <- fit.lda$resample$Accuracy
fit.lda
length(fit.lda$resample$Accuracy)
R.version
setwd("~/Documents/devel/tutorialML/hierarchical")
source('~/Documents/devel/tutorialML/hierarchical/actualFriedmanAccuracy.R')
actualFriedmanAccuracy (friedmanType = 2, reps = 500)
